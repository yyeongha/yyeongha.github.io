---
title: AI-DX education 3ì¡°_ì•Œì•½ í”„ë¡œì íŠ¸ ì‹¤íŒ¨ê¸°ë¡ (test_code2)
categories: [Project] 
date: 2024-06-10
last_modified_at: 2024-06-10
---
# 1. data
## 1) data í´ë” êµ¬ì¡°
ğŸ“¦test_code2
 â”£ ğŸ“‚data
 â”ƒ â”£ ğŸ“‚images # ì›ë³¸ ì´ë¯¸ì§€ 
 â”ƒ â”£ ğŸ“‚labels # ì›ë³¸ ë¼ë²¨
 â”ƒ â”£ ğŸ“‚dataset
 â”ƒ â”ƒ â”£ ğŸ“‚test
 â”ƒ â”ƒ â”ƒ â”£ ğŸ“‚images
 â”ƒ â”ƒ â”ƒ â”— ğŸ“‚labels
 â”ƒ â”ƒ â”£ ğŸ“‚train
 â”ƒ â”ƒ â”ƒ â”£ ğŸ“‚images
 â”ƒ â”ƒ â”ƒ â”— ğŸ“‚labels
 â”ƒ â”ƒ â”— ğŸ“‚valid
 â”ƒ â”ƒ â”ƒ â”£ ğŸ“‚images
 â”ƒ â”ƒ â”ƒ â”— ğŸ“‚labels
 â”ƒ â”— ğŸ“‚database
 â”ƒ â”ƒ â”— ğŸ“œpills_info.csv


## 2) ë°ì´í„° ìˆ˜ì§‘ ë°©ë²•
### (1) aihub
* ê²½êµ¬ì•½ì œ ì´ë¯¸ì§€ ë°ì´í„°
https://www.aihub.or.kr/aihubdata/data/view.do?currMenu=&topMenu=&aihubDataSe=data&dataSetSn=576

* 166.ì•½í’ˆì‹ë³„ - 01.ë°ì´í„° - ì›ì²œë°ì´í„° - ë‹¨ì¼ê²½êµ¬ì•½ì œ5000ì¢… - TS_51ë‹¨ì¼.zip ë‹¤ìš´

* TS_51ë‹¨ì¼.zip ì„ ê¹Œì„œ í”„ë¡œì íŠ¸ì— í•„ìš”í•œ ì•½ë§Œ ë‚¨ê¸°ê³  ì‚­ì œ
![TL_51]()
-> D:\3ì¡°_ì˜ì•½í’ˆ\dataset\data_test2\ì›ì²œ_ë‹¨ì¼ ê²½êµ¬ì•½ì œ ì´ë¯¸ì§€ ë°ì´í„°_51_59\01.ë°ì´í„°\1.Training\ì›ì²œë°ì´í„°\ë‹¨ì¼ê²½êµ¬ì•½ì œ 5000ì¢…\TS_51_ë‹¨ì¼ \
ì´ ê²½ë¡œì— ìˆìŒ

* TS_51_ë‹¨ì¼ íŒŒì¼ì—ì„œ ê° ì•½ë‹¹ í•œê°œì˜ ì‚¬ì§„ë§Œ ìˆëŠ” í´ë”ë¥¼ ë§Œë“¦ (ì›ì²œ_jpg_51)
-> D:\3ì¡°_ì˜ì•½í’ˆ\dataset\data_test2\ì›ì²œ_jpg_51 \
ì´ ê²½ë¡œì— ìˆìŒ

-> ì´ í´ë”ë¥¼ ë§Œë“  ì´ìœ ëŠ” roboflowì—ì„œ ë¼ë²¨ë§ ì‘ì—…ì„ í• ê±´ë° ê° ì•½ í´ë”ì— ì¡°ëª…, íšŒì „ì´ ë‹¤ë¥¸ ì•½ë“¤ì´ ìˆê¸° ë•Œë¬¸ì— ì¡°ëª…, íšŒì „ì´ ë””í´íŠ¸ê°’ì¸ ì•½ ì‚¬ì§„ í•˜ë‚˜ì”©ë§Œ í´ë”ì— ë„£ì—ˆë‹¤.

?ê°•ì‚¬ë‹˜ì—ê²Œ ë¬¼ì–´ë³¼ ì§ˆë¬¸? 
-> ëª¨ë¸ì„ í•™ìŠµì‹œí‚¤ë ¤ë©´ ì´ë¯¸ì§€ì™€ ë¼ë²¨ ë°ì´í„°ê°€ ìˆì–´ì•¼ í•˜ëŠ”ë°, ìš°ë¦¬ íŒ€ì´ ê°€ì§€ê³  ìˆëŠ” ì´ë¯¸ì§€ ë°ì´í„°ëŠ” ì•½ í•˜ë‚˜ë‹¹ ì¡°ëª…ê³¼ íšŒì „ì´ ê°ê° ë‹¤ë¥¸ ì‚¬ì§„ì´ ëŒ€ëµ 20ì¥ì”© ìˆë‹¤. ì‹œê°„ìƒ ê° ì´ë¯¸ì§€ë¥¼ ë¼ë²¨ë§ì„ ëª»í•  ê²ƒ ê°™ì€ë°, ê° ì•½ë‹¹ ëŒ€í‘œ ì´ë¯¸ì§€ë¥¼ ë½‘ì•„ì„œ ê·¸ê²ƒë§Œ ë¼ë²¨ë§ì„ í•œ í›„ ë°ì´í„° ì¦ê°•ì„ í•´ì„œ ëª¨ë¸ì„ í•™ìŠµì‹œì¼œë„ ë˜ëŠ”ì§€? 

### (2) roboflow
* roboflowì—ì„œ ì´ë¯¸ì§€ ë°ì´í„° ìë™ ë¼ë²¨ë§ í›„ ë°ì´í„° ì¦ê°•
![roboflow]()


## 2) dataset
* roboflowì—ì„œ ë§Œë“  ë°ì´í„°ì…‹(train, valid, test)ì„ datasetí´ë”ì— ì €ì¥


## 3) database
### (1) aihub
* 166.ì•½í’ˆì‹ë³„ - 01.ë°ì´í„° - ë¼ë²¨ë§ë°ì´í„° - ë‹¨ì¼ê²½êµ¬ì•½ì œ5000ì¢… - TS_51ë‹¨ì¼.zip

* TS_51ë‹¨ì¼.zip ì„ ê¹Œì„œ í”„ë¡œì íŠ¸ì— í•„ìš”í•œ ì•½ë§Œ ë‚¨ê¸°ê³  ì‚­ì œ
![TL_51]()
-> D:\3ì¡°_ì˜ì•½í’ˆ\dataset\data_test2\ë¼ë²¨ë§_ë‹¨ì¼_ê²½êµ¬ì•½ì œ ì´ë¯¸ì§€ ë°ì´í„°_51\01.ë°ì´í„°\1.Training\ë¼ë²¨ë§ë°ì´í„°\ë‹¨ì¼ê²½êµ¬ì•½ì œ 5000ì¢…\TL_51_ë‹¨ì¼ \
ì´ ê²½ë¡œì— ìˆìŒ

* TS_51ë‹¨ì¼.zip ì„ ê¹Œì„œ í”„ë¡œì íŠ¸ì— í•„ìš”í•œ ì•½ë§Œ ë‚¨ê¸°ê³  ì‚­ì œ
-> D:\3ì¡°_ì˜ì•½í’ˆ\dataset\data_test2\ë¼ë²¨ë§_json_51
ì´ ê²½ë¡œì— ìˆìŒ

* ìœ„ì˜ íŒŒì¼(json)ë“¤ì„ csv íŒŒì¼ë¡œ dl_nameì„ ê¸°ì¤€ìœ¼ë¡œ í•©ì³¤ë‹¤.
-> pills_info.csv íŒŒì¼
![pills_info]()


* pills_info.csv íŒŒì¼ì„ í”„ë¡œì íŠ¸ì˜ database í´ë”ì— ë„£ìŒ


# 2. models
## 1) models í´ë” êµ¬ì¡°

ğŸ“¦test_code2
â”£ ğŸ“‚models
 â”ƒ â”£ ğŸ“‚yolov8
 â”ƒ â”ƒ â”— ğŸ“œbest.pt
 â”ƒ â”— ğŸ“‚resnet
 â”ƒ â”ƒ â”— ğŸ“œbest.pt

## 2) resnet í•™ìŠµ
### (1) colab => resnet_training.ipynb
```
from google.colab import drive
drive.mount('/content/drive')

import torch
import torch.nn as nn
import torch.optim as optim
from torchvision import datasets, transforms, models
from torch.utils.data import DataLoader
```
```
# ë°ì´í„°ì…‹ ë¡œë“œ
transform = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.ToTensor(),
])

train_dataset = datasets.ImageFolder('/content/drive/MyDrive/Team3_pill/data/dataset/train/images', transform=transform)
train_loader = DataLoader(train_dataset, batch_size=32, shuffle=True)
```
```
# ResNet ëª¨ë¸ ì •ì˜
class ResNet(nn.Module):
    def __init__(self, num_classes):
        super(ResNet, self).__init__()
        # pretrained=False ëŒ€ì‹  weights=None ì‚¬ìš©
        self.model = models.resnet18(weights=None)
        num_ftrs = self.model.fc.in_features
        self.model.fc = nn.Linear(num_ftrs, num_classes)

    def forward(self, x):
        return self.model(x)

# í´ë˜ìŠ¤ ìˆ˜ ì„¤ì •
num_classes = 15  # ì˜ˆì‹œë¡œ í´ë˜ìŠ¤ ìˆ˜ë¥¼ 15ë¡œ ì„¤ì •

# ëª¨ë¸ ì´ˆê¸°í™”
model = ResNet(num_classes=num_classes)
```
-> ì§€ê¸ˆ ê°€ì§€ê³  ìˆëŠ” train ë°ì´í„°ì…‹ì´ ì ì–´ì„œ resnet18 ì‚¬ìš©í•¨
-> í´ë˜ìŠ¤ ìˆ˜ = ì•½ì˜ ê°¯ìˆ˜(ì•½ì˜ í´ë” ìˆ˜)

```
# ì†ì‹¤ í•¨ìˆ˜ì™€ ì˜µí‹°ë§ˆì´ì € ì •ì˜
criterion = nn.CrossEntropyLoss() 
optimizer = optim.Adam(model.parameters(), lr=0.001) 
```
-> criterion : ëª¨ë¸ì˜ ì¶œë ¥(ê° í´ë˜ìŠ¤ì— ëŒ€í•œ í™•ë¥  ë¶„í¬)ê³¼ ì‹¤ì œ ì •ë‹µ ë ˆì´ë¸”ì„ ë¹„êµí•˜ì—¬ ì†ì‹¤ì„ ê³„ì‚°
-> optimizer : ì˜µí‹°ë§ˆì´ì €ë¥¼ ì‚¬ìš©í•˜ì—¬ ëª¨ë¸ì˜ ê°€ì¤‘ì¹˜ë¥¼ ì—…ë°ì´íŠ¸í•  ë°©ë²•ì„ ì„¤ì •. í•™ìŠµë¥ ì€ 0.001ë¡œ ì„¤ì •

```
# í•™ìŠµ ë£¨í”„
num_epochs = 10 # ì „ì²´ í•™ìŠµ ë°˜ë³µ íšŸìˆ˜ë¥¼ 10ìœ¼ë¡œ ì„¤ì •
for epoch in range(num_epochs):
    model.train()
    running_loss = 0.0 
    for images, labels in train_loader:
        optimizer.zero_grad() 
        outputs = model(images) 
        loss = criterion(outputs, labels) 
        loss.backward() 
        optimizer.step() 
        running_loss += loss.item() 

    print(f"Epoch [{epoch+1}/{num_epochs}], Loss: {running_loss/len(train_loader)}")
```
![resnet_epoch]()

-> num_epochs = 10 : ì „ì²´ í•™ìŠµ ë°˜ë³µ íšŸìˆ˜ë¥¼ 10ìœ¼ë¡œ ì„¤ì •, ë°ì´í„° ìˆ˜ê°€ ì ì–´ì„œ ë†’ì€ epochìœ¼ë¡œ ì„¤ì •í•  ê²½ìš° ê³¼ì í•©ì´ ë°œìƒí•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì—
-> running_loss = 0.0 : í•œ ì—í­ ë™ì•ˆ ë°œìƒí•˜ëŠ” ì´ ì†ì‹¤ ê°’ì„ ëˆ„ì í•˜ê¸° ìœ„í•œ ë³€ìˆ˜ë¥¼ ì´ˆê¸°í™”
-> optimizer.zero_grad() : ì˜µí‹°ë§ˆì´ì €ì˜ ê¸°ìš¸ê¸°(gradient)ë¥¼ ì´ˆê¸°í™”
-> outputs = model(images) : ëª¨ë¸ì— ì´ë¯¸ì§€ ë°ì´í„°(images)ë¥¼ ì…ë ¥ìœ¼ë¡œ ë„£ì–´ ì˜ˆì¸¡ê°’(outputs)ì„ ì–»ìŒ
-> loss = criterion(outputs, labels) : ì†ì‹¤ í•¨ìˆ˜(criterion)ë¥¼ ì‚¬ìš©í•˜ì—¬ ëª¨ë¸ì˜ ì˜ˆì¸¡ê°’(outputs)ê³¼ ì‹¤ì œ ì •ë‹µ ë ˆì´ë¸”(labels) ê°„ì˜ ì°¨ì´ë¥¼ ê³„ì‚°í•˜ì—¬ ì†ì‹¤ ê°’(loss)
-> loss.backward() : ì—­ì „íŒŒ(backpropagation) ì•Œê³ ë¦¬ì¦˜ì„ í†µí•´ ì†ì‹¤ ê°’ì„ ê¸°ë°˜ìœ¼ë¡œ ê° ê°€ì¤‘ì¹˜ì— ëŒ€í•œ ê¸°ìš¸ê¸°ë¥¼ ê³„ì‚°
-> optimizer.step() : ê³„ì‚°ëœ ê¸°ìš¸ê¸°ë¥¼ ì‚¬ìš©í•˜ì—¬ ì˜µí‹°ë§ˆì´ì €ê°€ ëª¨ë¸ì˜ ê°€ì¤‘ì¹˜ë¥¼ ì—…ë°ì´íŠ¸
-> running_loss += loss.item() : í˜„ì¬ ë°°ì¹˜ì˜ ì†ì‹¤ ê°’ì„ running_lossì— ëˆ„ì í•˜ì—¬ í•œ ì—í­ ë™ì•ˆì˜ ì´ ì†ì‹¤ ê°’ì„ ê³„ì‚°

```
# ëª¨ë¸ ì €ì¥
torch.save(model.state_dict(), '/content/drive/MyDrive/Team3_pill/model/resnet/best.pt')
print("Model saved successfully!")
```

* ì €ì¥ëœ best.ptíŒŒì¼ì„ í”„ë¡œì íŠ¸ì˜ model/resnet í´ë”ì— ì €ì¥

## 3) yolov8 í•™ìŠµ
### (2) colab => yolov8_training.ipynb
```
from google.colab import drive
drive.mount('/content/drive')
```

```
import torch
from torch.utils.data import DataLoader
from torchvision import datasets, transforms
import torch.nn as nn
import torch.optim as optim
```

```
# ë°ì´í„°ì…‹ ë¡œë“œ
transform = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.ToTensor(),
])

train_dataset = datasets.ImageFolder('/content/drive/MyDrive/Team3_pill/data/dataset/train/images', transform=transform)
train_loader = DataLoader(train_dataset, batch_size=32, shuffle=True)
```
```
class YOLOv8(nn.Module):
    def __init__(self, num_classes):
        super(YOLOv8, self).__init__()
        # YOLOv8 ë ˆì´ì–´ ì •ì˜
        self.conv1 = nn.Conv2d(3, 16, kernel_size=3, stride=1, padding=1)
        self.conv2 = nn.Conv2d(16, 32, kernel_size=3, stride=1, padding=1)
        self.fc1 = nn.Linear(32 * 224 * 224, 1000)
        self.fc2 = nn.Linear(1000, num_classes)  # í´ë˜ìŠ¤ ìˆ˜ì— ë§ê²Œ ì—…ë°ì´íŠ¸

    def forward(self, x):
        x = torch.relu(self.conv1(x))
        x = torch.relu(self.conv2(x))
        x = x.view(x.size(0), -1)
        x = torch.relu(self.fc1(x))
        x = self.fc2(x)
        return x

num_classes = 15  # í´ë˜ìŠ¤ ìˆ˜ = ì•½ í´ë” ìˆ˜ 
model = YOLOv8(num_classes)
```

```
# ì†ì‹¤ í•¨ìˆ˜ì™€ ì˜µí‹°ë§ˆì´ì € ì •ì˜
criterion = torch.nn.CrossEntropyLoss()
optimizer = torch.optim.Adam(model.parameters(), lr=0.001)
```
```
# í›ˆë ¨ ë£¨í”„
num_epochs = 10
for epoch in range(num_epochs):
    model.train()
    running_loss = 0.0
    for images, labels in train_loader:
        optimizer.zero_grad()
        outputs = model(images)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()
        running_loss += loss.item()

    print(f"Epoch [{epoch+1}/{num_epochs}], Loss: {running_loss/len(train_loader):.4f}")
```
![yolo_epoch]()

```
# ëª¨ë¸ ì €ì¥
torch.save(model.state_dict(), '/content/drive/MyDrive/Team3_pill/model/yolov8/best.pt')
```

* ì €ì¥ëœ best.ptíŒŒì¼ì„ í”„ë¡œì íŠ¸ì˜ model/yolov8 í´ë”ì— ì €ì¥


# 3. scripts
## 1) scripts í´ë” êµ¬ì¡°
ğŸ“¦test_code2
ğŸ“‚scripts
    â”£ ğŸ“‚__pycache__
    â”ƒ â”£ ğŸ“œutils.cpython-38.pyc
    â”ƒ â”£ ğŸ“œyolov8.cpython-38.pyc
    â”ƒ â”£ ğŸ“œresnet.cpython-38.pyc
    â”ƒ â”£ ğŸ“œpill_detection.cpython-38.pyc
    â”ƒ â”— ğŸ“œclova_ocr.cpython-38.pyc
    â”£ ğŸ“œpill_detection.py
    â”£ ğŸ“œutils.py
    â”£ ğŸ“œyolov8.py
    â”£ ğŸ“œresnet.py
    â”— ğŸ“œclova_ocr.py

## 2) utils.py
```
import torch

def load_model(model_path, model_class):
    """
    ëª¨ë¸ì„ ë¡œë“œí•˜ëŠ” í•¨ìˆ˜
    """
    model = model_class()
    model.load_state_dict(torch.load(model_path))
    model.eval()
    return model
```
ê³µí†µìœ¼ë¡œ ì‚¬ìš©ë˜ëŠ” ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤ì„ í¬í•¨í•˜ëŠ” íŒŒì¼ì´ë‹¤. ì£¼ë¡œ ëª¨ë¸ì„ ë¡œë“œí•˜ëŠ” í•¨ìˆ˜ë¥¼ ì •ì˜

## 3) resnet.py
```
import torch
import torch.nn as nn
import torchvision.models as models

class ResNet(nn.Module):
    def __init__(self, num_classes=15):  # í•„ìš”í•œ í´ë˜ìŠ¤ ìˆ˜ì— ë”°ë¼ ìˆ˜ì •
        super(ResNet, self).__init__()
        self.model = models.resnet18(pretrained=False)  # pretrained=Falseë¡œ ë³€ê²½
        num_ftrs = self.model.fc.in_features
        self.model.fc = nn.Linear(num_ftrs, num_classes)

    def forward(self, x):
        return self.model(x)
```
ResNet ëª¨ë¸ì„ ì •ì˜í•˜ëŠ” íŒŒì¼ì´ë‹¤. ResNet ëª¨ë¸ì˜ êµ¬ì¡°ë¥¼ ì •ì˜í•˜ê³ , ë¶„ë¥˜ë¥¼ ìˆ˜í–‰í•  ìˆ˜ ìˆë„ë¡ í•œë‹¤.


## 4) yolov8.py
```
import torch
from ultralytics import YOLO

class YOLOv8:
    def __init__(self):
        # YOLOv8 ëª¨ë¸ ì´ˆê¸°í™”
        self.model = YOLO('yolov8n.pt')  # YOLOv8n ëª¨ë¸ì„ ì‚¬ìš©í•©ë‹ˆë‹¤. ë‹¤ë¥¸ ëª¨ë¸ì„ ì›í•  ê²½ìš° ê²½ë¡œë¥¼ ë³€ê²½í•˜ì„¸ìš”.

    def detect(self, image):
        # ëª¨ë¸ì„ ì‚¬ìš©í•˜ì—¬ ì´ë¯¸ì§€ì—ì„œ ê°ì²´ ê²€ì¶œ
        results = self.model(image)
        return results
```
YOLOv8 ëª¨ë¸ì„ ì •ì˜í•˜ê³  ê°ì²´ íƒì§€ë¥¼ ìˆ˜í–‰í•˜ëŠ” íŒŒì¼


## 5) clova_ocr.py
```
import requests
import cv2
import json
import uuid
import time

# Clova OCR API ì •ë³´ (í™˜ê²½ ë³€ìˆ˜ë‚˜ ì„¤ì • íŒŒì¼ë¡œë¶€í„° ë¡œë“œ)
CLOVA_OCR_URL = 'put your url'
CLOVA_OCR_KEY = 'put your ocr key'

def call_clova_ocr(image):
    """
    Clova OCR APIë¥¼ í˜¸ì¶œí•˜ì—¬ ì´ë¯¸ì§€ì—ì„œ í…ìŠ¤íŠ¸ë¥¼ ì¸ì‹í•˜ëŠ” í•¨ìˆ˜
    """
    print("Starting OCR process...")
    _, encoded_image = cv2.imencode('.jpg', image)
    image_data = encoded_image.tobytes()
    print("Image encoded successfully.")

    headers = {
        'X-OCR-SECRET': CLOVA_OCR_KEY,
    }
    print("Headers set.")

    request_json = {
        'images': [{'format': 'jpg', 'name': 'demo'}],
        'requestId': str(uuid.uuid4()),
        'version': 'V2',
        'timestamp': int(round(time.time() * 1000))
    }

    payload = {'message': json.dumps(request_json).encode('UTF-8')}
    files = [('file', image_data)]

    response = requests.post(CLOVA_OCR_URL, headers=headers, data=payload, files=files)
    print(f"OCR request sent. Status code: {response.status_code}")

    if response.status_code == 200:
        result = response.json()
        print("OCR request successful.")
        if 'images' in result and len(result['images']) > 0:
            return result['images'][0]['inferResult']
        else:
            print("No 'images' field in OCR response.")
            return None
    else:
        print(f"Error {response.status_code}: {response.text}")
        return None
```

ë„¤ì´ë²„ í´ë¡œë°” OCR APIë¥¼ í˜¸ì¶œí•˜ì—¬ ì´ë¯¸ì§€ì—ì„œ í…ìŠ¤íŠ¸ë¥¼ ì¸ì‹í•˜ëŠ” íŒŒì¼


## 6) pill_detection.py
```
import cv2
import pandas as pd
import torch
from PIL import Image
from torchvision import transforms
import matplotlib.pyplot as plt
from ultralytics import YOLO

# Load YOLOv8 and ResNet models
from scripts.yolov8 import YOLOv8
from scripts.resnet import ResNet
from scripts.utils import load_model
from scripts.clova_ocr import call_clova_ocr

# YOLOv8 ë° ResNet ëª¨ë¸ ë¡œë“œ
yolov8_model = YOLOv8()
resnet_model = load_model('models/resnet/best.pt', ResNet)

# ì•Œì•½ ì •ë³´ ë°ì´í„°ë² ì´ìŠ¤ ë¡œë“œ
pill_info_df = pd.read_csv('data/database/pills_info.csv')

def detect_pills(image):
    """
    YOLOv8ë¥¼ ì‚¬ìš©í•˜ì—¬ ì´ë¯¸ì§€ì—ì„œ ì•Œì•½ì„ ê²€ì¶œí•˜ëŠ” í•¨ìˆ˜
    """
    results = yolov8_model.detect(image)
    return results

def recognize_imprint(pill_image):
    """
    ë„¤ì´ë²„ í´ë¡œë°” OCRì„ ì‚¬ìš©í•˜ì—¬ ì•Œì•½ì˜ ê°ì¸ ì¸ì‹
    """
    print("Starting to recognize imprint...")
    result = call_clova_ocr(pill_image)
    if result and 'fields' in result:
        imprint_text = ' '.join([field['inferText'] for field in result['fields']])
        return imprint_text
    print("No text recognized.")
    return ""

def classify_pill(pill_image):
    """
    ResNetì„ ì‚¬ìš©í•˜ì—¬ ì•Œì•½ì„ ë¶„ë¥˜í•˜ëŠ” í•¨ìˆ˜
    """
    transform = transforms.Compose([
        transforms.Resize((224, 224)),
        transforms.ToTensor(),
    ])
    pill_image = transform(Image.fromarray(pill_image))
    pill_image = pill_image.unsqueeze(0)  # ë°°ì¹˜ ì°¨ì› ì¶”ê°€
    output = resnet_model(pill_image)
    _, predicted = torch.max(output, 1)
    return predicted.item()

def get_pill_info(imprint):
    """
    ê°ì¸ì„ í†µí•´ ì•Œì•½ ì •ë³´ë¥¼ ì¡°íšŒí•˜ëŠ” í•¨ìˆ˜
    """
    if 'print_front_x' not in pill_info_df.columns:
        raise KeyError("'print_front_x' column not found in the pill information database.")
    
    pill_info = pill_info_df[pill_info_df['print_front_x'] == imprint]
    if not pill_info.empty:
        return pill_info.iloc[0]
    else:
        return None

def plot_results(image, boxes, imprints):
    """
    ê²€ì¶œ ê²°ê³¼ì™€ ê°ì¸ì„ ì‹œê°í™”í•˜ëŠ” í•¨ìˆ˜
    """
    for (box, imprint) in zip(boxes, imprints):
        x1, y1, x2, y2 = box.xyxy[0].tolist()
        conf = box.conf[0].item()
        cls = box.cls[0].item()
        cv2.rectangle(image, (int(x1), int(y1)), (int(x2), int(y2)), (0, 255, 0), 2)
        label = f"pill"
        cv2.putText(image, label, (int(x1), int(y1) - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.9, (0, 255, 0), 2)
    
    plt.figure(figsize=(10, 10))
    plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
    plt.axis('off')
    plt.show()

def main(image_path):
    """
    ë©”ì¸ í•¨ìˆ˜
    """
    image = cv2.imread(image_path)
    results = detect_pills(image)  # ëª¨ë¸ì„ ì‚¬ìš©í•˜ì—¬ ê°ì²´ ê²€ì¶œ
    print("Detection results:", results)  # ê²°ê³¼ êµ¬ì¡° í™•ì¸

    if results[0].boxes is not None:  # ê²°ê³¼ê°€ ì¡´ì¬í•˜ëŠ” ê²½ìš°
        boxes = results[0].boxes
    else:
        print("No detections found.")
        return

    imprints = []
    for box in boxes:
        x1, y1, x2, y2 = map(int, box.xyxy[0].tolist())
        pill_image = image[y1:y2, x1:x2]
        imprint = recognize_imprint(pill_image)
        
        if imprint:
            print(f"Recognized Imprint: {imprint}")
        else:
            print("ì•Œì•½ ê¸€ì”¨ ì¸ì‹ ëª»í•¨")
        
        imprints.append(imprint)
        
        pill_class = classify_pill(pill_image)
        print(f"Pill Class: {pill_class}")

        pill_info = get_pill_info(imprint)
        if pill_info is not None:
            print(f"ì•Œì•½ ì´ë¦„: {pill_info['dl_name']}")
            print(f"ì„±ë¶„: {pill_info['dl_material_x']}")
        else:
            print("ì•Œì•½ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")

    plot_results(image, boxes, imprints)

if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser(description="Pill Detection Project Main Script")
    parser.add_argument('--image', type=str, help='Path to the image file', required=True)
    args = parser.parse_args()

    main(args.image)

```

ëª¨ë“  ëª¨ë“ˆì„ í†µí•©í•˜ì—¬ ì•Œì•½ì„ ê²€ì¶œí•˜ê³ , ë¶„ë¥˜í•˜ë©°, OCRì„ í†µí•´ ê°ì¸ì„ ì¸ì‹í•˜ëŠ” ë©”ì¸ íŒŒì¼

* YOLOv8ë¥¼ ì‚¬ìš©í•˜ì—¬ ì•Œì•½ ê²€ì¶œ
* ResNetì„ ì‚¬ìš©í•˜ì—¬ ì•Œì•½ ë¶„ë¥˜
* Clova OCRì„ ì‚¬ìš©í•˜ì—¬ ê°ì¸ ì¸ì‹
* ê²°ê³¼ ì‹œê°í™” ë° ì¶œë ¥

# 4. main.py









---